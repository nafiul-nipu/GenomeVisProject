Metadata-Version: 2.4
Name: mpase
Version: 0.1.0
Summary: MultiPointAlignmentShapeExtractor: align multiple 3D point clouds, extract HDR and point-fraction shapes, and export visuals/data.
Author-email: Md Nafiul Nipu <mnipu2@uic.edu>
License: MIT
Keywords: point cloud,alignment,HDR,KDE,silhouette,3D,shape
Classifier: Programming Language :: Python :: 3
Classifier: License :: OSI Approved :: MIT License
Classifier: Intended Audience :: Science/Research
Classifier: Topic :: Scientific/Engineering :: Information Analysis
Requires-Python: >=3.9
Description-Content-Type: text/markdown
Requires-Dist: numpy>=1.23
Requires-Dist: pandas>=2.0
Requires-Dist: scipy>=1.10
Requires-Dist: scikit-image>=0.21
Requires-Dist: scikit-learn>=1.3
Requires-Dist: matplotlib>=3.7
Provides-Extra: dev
Requires-Dist: pytest>=7.4; extra == "dev"
Requires-Dist: black>=24.0.0; extra == "dev"
Requires-Dist: ruff>=0.6.0; extra == "dev"
Requires-Dist: mypy>=1.7.0; extra == "dev"

# MultiPointAlignmentShapeExtractor (MPASE)

**MultiPointAlignmentShapeExtractor (MPASE)** is a pipeline for aligning multiple 3D point clouds, extracting density- and fraction-based shapes, and generating comparable visual and data outputs.

# ----- Imports -----

from mpase import (
run_silhouettes,
CfgCommon, CfgHDR, CfgPF, CfgMorph,
view, save_figures, # overlay (existing)
view_projections, save_projections,
view_single, save_per_label, # NEW: single-label (no overlay)
export_all, # OPTIONAL: per-label background exporter
export_background_mask_by_label_json,
)

from mpase import export_all # pure-data web bundle (D3/Three)

# --------------------------------------------------------------------------------------------

# 1) INPUTS

# --------------------------------------------------------------------------------------------

# Provide EITHER:

# (A) csv_list: list[str] paths OR

# (B) points_list: list[np.ndarray] with shape (Ni, 3)

# Optionally provide 'labels' (must match list length). If omitted → auto ["S0","S1",...]

csv_list = [

# CSVs MUST contain 3D coordinate columns matching xyz_cols (default: middle_x/y/z).

"data/green_monkey/all_structure_files/chr1/12hrs/untr/structure_12hrs_untr_gene_info.csv",
"data/green_monkey/all_structure_files/chr1/12hrs/vacv/structure_12hrs_vacv_gene_info.csv",

# Add more sets as needed...

]
labels = ["12h_UNTR", "12h_VACV"] # Optional; if omitted → ["S0", "S1", ...]

# All outputs (metrics, figures, JSON) will be written under:

out_dir = "data/green_monkey/va_testing/silhouette_analysis_output"

# --------------------------------------------------------------------------------------------

# 2) CONFIGURATION OBJECTS (all fields documented below)

# --------------------------------------------------------------------------------------------

# CfgCommon — alignment/grid/output

cfg_common = CfgCommon(
grid_base=160, # int: longest side of shared 3D grid → sets heatmap/mask resolution
pad_frac=0.05, # float: padding around global bbox (fraction of max extent)
trim_q=0.10, # float [0..0.5): ICP outlier trim per iter (discard worst trim_q matches)
icp_iters=30, # int: number of ICP iterations (try 50 for hard cases)
sample_icp=50000, # int or None: max points sampled per set for ICP (None=use all)
)

# CfgHDR — highest-density-region silhouettes via bootstrap-averaged 2D densities

cfg_hdr = CfgHDR(
n_boot=256, # int: bootstrap resamples per set
sample_frac=1.0, # float (0..1]: fraction of points per resample (1.0=with replacement)
sigma_px=1.2, # float: Gaussian blur sigma in pixels on 2D hist grid
density_floor_frac=0.002,# float: zero-out tiny densities (as frac of D.max) before threshold search
mass_levels=( # tuple of floats in [0..1]: HDR coverage levels to extract
1.00,0.99,0.98,0.97,0.96,0.95,0.90,0.80,0.60,0.50
),
rng_seed=0 # int: RNG seed for bootstrap reproducibility
)

# Optional morphology for point-fraction masks

cfg_morph = CfgMorph(
closing=1, # int: binary_closing iterations (seal small gaps)
opening=1, # int: binary_opening iterations (remove specks)
keep_largest=True, # bool: keep only the largest connected component
fill_holes=True # bool: fill holes in kept component(s)
)

# CfgPF — point-fraction silhouettes (densest ceil(frac\*N) points by KDE score)

cfg_pf = CfgPF(
frac_levels=( # tuple of floats in [0..1]: density-fraction levels to extract
1.00,0.99,0.98,0.97,0.96,0.95,0.90,0.80,0.60,0.50
),
bandwidth=None, # float or None: KDE bandwidth; None → auto (median pairwise dist \* 0.5)
disk_px=2, # int: raster disk radius (px) when painting kept points to mask
morph=cfg_morph # CfgMorph: morphological cleanup options for PF masks
)

# --------------------------------------------------------------------------------------------

# 3) RUN PIPELINE

# --------------------------------------------------------------------------------------------

# run_silhouettes parameters:

# csv_list: Optional[Seq[str]] # EITHER csv_list OR points_list (required)

# points_list: Optional[Seq[np.ndarray]]# "

# labels: Optional[Seq[str]] # names used in metrics/figures/exports (len must match inputs)

# xyz_cols: Tuple[str,str,str] # CSV x,y,z column names (default: ("middle_x","middle_y","middle_z"))

# align_mode: Literal["auto","skip"] # "auto"=PCA prealign + robust ICP to first set; "skip"=center only

# point_alignment_only: bool # if True OR (not run_hdr and not run_pf): stop after alignment

# out_dir: Optional[str] # only needed when point_alignment_only is True

# run_hdr: bool # compute HDR silhouettes

# run_pf: bool # compute PF silhouettes

# cfg_common: Optional[CfgCommon] # common/alignment/grid/output config

# cfg_hdr: Optional[CfgHDR] # HDR config

# cfg_pf: Optional[CfgPF] # PF config

# planes: Tuple[Plane,...] # planes to compute/plot ("XY","YZ","XZ") — any subset ok

#

# Returns: dict with keys:

# labels, aligned_points, shapes, metrics(pd.DataFrame), meta, background, densities|None, projections

res = run_silhouettes(
csv_list=csv_list, # points_list=None, # (alternative) list of (Ni,3) float arrays
labels=labels,
xyz_cols=("middle_x","middle_y","middle_z"),
align_mode="auto", # "auto" or "skip"
point_alignment_only=False, # set True for alignment + projections + background only
out_dir=out_dir,
run_hdr=True, # toggle HDR branch
run_pf=True, # toggle PF branch
cfg_common=cfg_common,
cfg_hdr=cfg_hdr,
cfg_pf=cfg_pf,
planes=("XY","YZ","XZ")
)

# --------------------------------------------------------------------------------------------

# 4) METRICS

# --------------------------------------------------------------------------------------------

# res["metrics"] columns: plane, level, mode("hdr"|"point_fraction"), A, B, IoU, meanNN, Hausdorff

print(res["metrics"].head())

# CSV copy written at: f"{out_dir}/metrics_data.csv"

# JSON meta written at: f"{out_dir}/meta_data.json"

# --------------------------------------------------------------------------------------------

# 5) VISUALIZATION

# --------------------------------------------------------------------------------------------

# (a) 2D scatter of aligned 3D points, per plane

view_projections(
res,
planes=("XY","YZ","XZ"),
A_lab="12h_UNTR", B_lab="12h_VACV",
labelA="12 h — UNTR", labelB="12 h — VACV",
s=3.0, alphaA=0.7, alphaB=0.7
)

# (b) HDR silhouette overlays (+ optional density heat for A)

view(
res, kind="hdr", plane="XY", levels="all",
A_lab="12h_UNTR", B_lab="12h_VACV",
labelA="12 h — UNTR", labelB="12 h — VACV",
show_heat=True,
clean_blobs=False, // clean small blobs (true or false)
blob_min_len=15, // drop very short contours
blob_min_area_frac=0.05 // drop blobs < 5% of largest
)

# (c) Point-fraction silhouettes at chosen levels

view(
res, kind="point_fraction", plane="XY", levels=[100,95,80],
A_lab="12h_UNTR", B_lab="12h_VACV",
labelA="12 h — UNTR", labelB="12 h — VACV",
show_heat=False, clean_blobs=True, blob_min_len=15, blob_min_area_frac=0.08
)

# (d) Single-label view (no overlay; uses per-label background)

```python
from visualization_save_image import view_single

# Show only UNTR, HDR at 100% and 95%, XY plane
view_single(
    res, label="12h_UNTR",
    kind="hdr", plane="XY", levels=[100, 95],
    show_heat=True,  # optional: HDR heatmap underneath
    clean_blobs=True, blob_min_len=15, blob_min_area_frac=0.08
)

# --------------------------------------------------------------------------------------------

# 6) SAVE FIGURES

# --------------------------------------------------------------------------------------------

save_projections(
res, out_dir=out_dir, planes=("XY","YZ","XZ"),
A_lab="12h_UNTR", B_lab="12h_VACV",
labelA="12 h — UNTR", labelB="12 h — VACV",
s=3.0, alphaA=0.7, alphaB=0.7,
dpi=220, save_csv=True
)

save_figures(
res, kind="hdr", plane="XY", levels="all",
out_dir=out_dir, show_heat=True,
A_lab="12h_UNTR", B_lab="12h_VACV",
labelA="12 h — UNTR", labelB="12 h — VACV", clean_blobs=True, blob_min_len=15, blob_min_area_frac=0.08
)

save_figures(
res, kind="point_fraction", plane="YZ", levels=[95,50],
out_dir=out_dir,
A_lab="12h_UNTR", B_lab="12h_VACV",
labelA="12 h — UNTR", labelB="12 h — VACV", clean_blobs=True, blob_min_len=15, blob_min_area_frac=0.08
)

### Save per label (no overlay)
from visualization_save_image import save_per_label

# Save PF 100/95/80 for each condition as separate PNGs
save_per_label(
    res,
    labels=("12h_UNTR","12h_VACV"),  # omit to save all labels
    kind="point_fraction", plane="XY", levels=[100,95,80],
    out_dir=f"{out_dir}/figures_single",
    show_heat=False, clean_blobs=True, blob_min_len=15, blob_min_area_frac=0.08
)

# --------------------------------------------------------------------------------------------

# 7) EXPORT PURE-DATA WEB BUNDLE (multi-set aware)

# --------------------------------------------------------------------------------------------

# export_all parameters:

# result: RunResult

# out_dir: str

# include*density: bool # write density*<label>.json per label (if HDR exists)

# export_layout: bool # write layout.json (3D slice placement)

# export_scales: bool # write scales.json (global bbox across ALL sets)

# kind_levels: Dict[str, int|Iterable[int]|"all"] # keys: "hdr" and/or "point_fraction"

# which_density: Optional[Iterable[str]] # limit which labels to emit densities for (None=all)

# progress_report: bool # prints progress notification # True or False

# clean_blob: bool # cleans small blobs

# blob_min_len: minimum length

# blob_min_area_frac

export_all(
res,
out_dir=out_dir,
include_density=True,
export_layout=True,
export_scales=True,
kind_levels={"hdr": "all", "point_fraction": "all"},
which_density=None,
progress_report=True,
clean_blobs=False,
    blob_min_len=15,
    blob_min_area_frac=0.05,
)

# --------------------------------------------------------------------------------------------

# Output bundle includes (as implemented in the multi-set exporters):

# --------------------------------------------------------------------------------------------

# meta_data.json (planes, grid sizes, available levels, labels)

# background_mask.json (per-plane union-of-presence mask, 0/1)

# export_background_mask_by_label_json(result, out_dir)  # writes per-label masks only

# density\_<label>.json (bootstrapped 2D densities per plane, per label; only if HDR ran)

# contours_d3.json (for each variant/plane/level/label → polyline [x,y] in pixel space)

# projections.json (for each plane → {label: [[x,y],...]} in pixel image coords)

# metrics_data.json (pairwise metrics rows from res["metrics"])

# points3d.json ({label: {"positions":[[x,y,z],...]}} for all aligned sets)

# layout.json (optional: static 3D slice placement)

# scales.json (optional: bbox mins/maxs across ALL aligned points)

# --------------------------------------------------------------------------------------------

# OPTIONAL: Alignment-only quick run (no HDR/PF/metrics beyond projections/background)

# --------------------------------------------------------------------------------------------

# res_align = run_silhouettes(

# csv_list=csv_list,

# labels=labels,

# out_dir=out_dir,

# align_mode="auto",

# point_alignment_only=True,

# run_hdr=False,

# run_pf=False,

# planes=("XY","YZ","XZ"),

# )

# export_all(res_align, out_dir=f"{out_dir}/point_alignment_only", include_density=False)
```
