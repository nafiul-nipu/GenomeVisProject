<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>MPASE 2D SVG · Minimal Test (Aligned)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        --bg: #0b0b0c;
        --panel: #0e0e11;
        --fg: #eaeaea;
        --grid: #222;
        --scatter: #1f77b4; /* blue */
        --contour: #d62728; /* red */
      }
      html,
      body {
        margin: 0;
        padding: 0;
        background: var(--bg);
        color: var(--fg);
        font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      }
      header {
        padding: 10px 14px;
        border-bottom: 1px solid var(--grid);
      }
      #row {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 12px;
        padding: 12px;
      }
      .panel {
        background: var(--panel);
        border: 1px solid var(--grid);
        border-radius: 6px;
        overflow: hidden;
      }
      .panel h3 {
        margin: 0;
        padding: 8px 10px;
        background: #111214;
        font-weight: 600;
      }
      .panel .body {
        padding: 8px;
      }
      svg {
        display: block;
        width: 100%;
        height: auto;
        background: #0f1013;
        border-radius: 4px;
      }
      .points circle {
        fill: var(--scatter);
        fill-opacity: 0.85;
        r: 1.6;
      }
      .contours path {
        fill: none;
        stroke: var(--contour);
        stroke-width: 1.8;
        stroke-opacity: 0.95;
        vector-effect: non-scaling-stroke;
      }
      .foot {
        opacity: 0.75;
        padding: 8px 12px;
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  </head>
  <body>
    <header>
      <select id="labSel"></select>
      <strong>MPASE 2D SVG · Minimal Test</strong>
      <div class="foot">
        Assumes pixel-aligned outputs. Toggle variant/level to test containment.
      </div>
      <div class="foot">
        Variant:
        <select id="variant">
          <option value="hdr">hdr</option>
          <option value="pf">pf</option>
        </select>
        Level:
        <input
          id="level"
          type="number"
          value="95"
          min="50"
          max="100"
          step="1"
          style="width: 64px"
        />
      </div>
    </header>

    <div id="row"></div>

    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script>
      (async function () {
        const ROOT = "web_data";
        const PLANES = ["XY", "XZ", "YZ"];
        const PROJ = (p) => `${ROOT}/projections/${p}_projections.json`;
        const CNT = (lab) =>
          `${ROOT}/contours/${lab.replace(
            /[^A-Za-z0-9._-]+/g,
            "_"
          )}_contour.json`;
        const BG = `${ROOT}/background_mask.json`;

        const selLab = document.getElementById("labSel");
        const selVar = document.getElementById("variant");
        const inpLvl = document.getElementById("level");
        const row = d3.select("#row");

        // dims from background so our SVG lattice matches contours exactly
        const bg = await fetch(BG).then((r) => r.json());
        const dims = {};
        for (const plane of PLANES) {
          const arr = bg[plane];
          if (Array.isArray(arr) && arr.length) {
            dims[plane] = { nx: arr[0].length, ny: arr.length };
          }
        }

        // load projections for one plane to get labels
        const firstProj = await fetch(PROJ(PLANES[0])).then((r) => r.json());
        const labels = Object.keys(firstProj || {});
        labels.forEach((l) => {
          const o = document.createElement("option");
          o.value = l;
          o.textContent = l;
          selLab.appendChild(o);
        });
        selLab.value = labels[0] || "";

        // point-in-polygon (ray casting)
        function insidePoly(pt, poly) {
          const x = pt[0],
            y = pt[1];
          let inside = false;
          for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
            const xi = poly[i][0],
              yi = poly[i][1];
            const xj = poly[j][0],
              yj = poly[j][1];
            const intersect =
              yi > y !== yj > y &&
              x < ((xj - xi) * (y - yi)) / Math.max(1e-9, yj - yi) + xi;
            if (intersect) inside = !inside;
          }
          return inside;
        }

        async function render() {
          row.selectAll("*").remove();
          const label = selLab.value;
          const variant = selVar.value; // "hdr" or "pf"
          const level = +inpLvl.value; // integer level key in contour json

          // load all contours for this label once
          let cJson = null;
          try {
            cJson = await fetch(CNT(label)).then((r) => r.json());
          } catch {}
          const byPlaneMode = d3.group(
            cJson?.contours || [],
            (d) => d.plane,
            (d) => d.variant,
            (d) => +d.level
          );

          for (const plane of PLANES) {
            if (!dims[plane]) continue;
            const { nx, ny } = dims[plane];

            // panel
            const div = row.append("div").attr("class", "panel");
            div.append("h3").text(plane);
            const body = div.append("div").attr("class", "body");
            const svg = body
              .append("svg")
              .attr("viewBox", `0 0 ${nx} ${ny}`)
              .attr("preserveAspectRatio", "xMidYMid meet");
            const gOut = svg.append("g").attr("class", "points outside");
            const gPts = svg.append("g").attr("class", "points");
            const gCtr = svg.append("g").attr("class", "contours");

            // projections for this plane/label (already pixel coords)
            const proj = await fetch(PROJ(plane)).then((r) => r.json());
            const pts = proj && proj[label] ? proj[label] : [];

            // pick contour for (plane, variant, level)
            const vkey = variant === "pf" ? "pf" : "hdr";
            const items = byPlaneMode.get(plane)?.get(vkey)?.get(level) || [];
            // if missing exact level, pick nearest available for this mode
            let pick = items;
            if (!items.length) {
              const lvls = Array.from(
                (byPlaneMode.get(plane)?.get(vkey) || new Map()).keys()
              );
              if (lvls.length) {
                let best = lvls[0],
                  bestd = Math.abs(lvls[0] - level);
                for (const L of lvls) {
                  const d = Math.abs(L - level);
                  if (d < bestd) {
                    best = L;
                    bestd = d;
                  }
                }
                pick = byPlaneMode.get(plane).get(vkey).get(best) || [];
              }
            }

            // draw contour(s)
            gCtr
              .selectAll("path")
              .data(pick)
              .join("path")
              .attr(
                "d",
                (d) =>
                  "M" +
                  (d.points || []).map((p) => `${p[0]},${p[1]}`).join("L") +
                  "Z"
              );

            // classify points against outermost polygon (largest area)
            let poly = [];
            if (pick.length) {
              let maxA = -1;
              for (const it of pick) {
                const p = it.points || [];
                let area = 0; // polygon area
                for (let i = 0; i < p.length; i++) {
                  const [x1, y1] = p[i],
                    [x2, y2] = p[(i + 1) % p.length];
                  area += x1 * y2 - x2 * y1;
                }
                area = Math.abs(area) / 2;
                if (area > maxA) {
                  maxA = area;
                  poly = p;
                }
              }
            }

            // split points: inside vs outside
            const outside = poly.length
              ? pts.filter((pt) => !insidePoly(pt, poly))
              : [];
            const inside = poly.length
              ? pts.filter((pt) => insidePoly(pt, poly))
              : pts;

            // draw points (inside = blue, outside = magenta)
            // --- DRAW POINTS AS RASTER BITMAPS ON THE SAME nx×ny LATTICE ---
            // Helper to paint a list of [x,y] (float) onto an ImageData as single pixels
            function paintPixels(nx, ny, pts, rgba) {
              const cvs = document.createElement("canvas");
              cvs.width = nx;
              cvs.height = ny;
              const ctx = cvs.getContext("2d", { willReadFrequently: true });
              const img = ctx.createImageData(nx, ny);
              const data = img.data;

              for (const [xf, yf] of pts) {
                const x = Math.max(0, Math.min(nx - 1, Math.round(xf)));
                const y = Math.max(0, Math.min(ny - 1, Math.round(yf)));
                const i = (y * nx + x) * 4;
                data[i + 0] = rgba[0]; // R
                data[i + 1] = rgba[1]; // G
                data[i + 2] = rgba[2]; // B
                data[i + 3] = rgba[3]; // A
              }
              ctx.putImageData(img, 0, 0);
              return cvs.toDataURL("image/png");
            }

            // Inside = blue, Outside = magenta
            const urlInside = paintPixels(nx, ny, inside, [31, 119, 180, 255]); // #1f77b4
            const urlOutside = paintPixels(
              nx,
              ny,
              outside,
              [255, 47, 213, 255]
            ); // #ff2fd5

            // Add as SVG <image> layers (outside on top so misses pop visually)
            svg
              .append("image")
              .attr("href", urlInside)
              .attr("x", 0)
              .attr("y", 0)
              .attr("width", nx)
              .attr("height", ny)
              .attr("opacity", 0.95);

            svg
              .append("image")
              .attr("href", urlOutside)
              .attr("x", 0)
              .attr("y", 0)
              .attr("width", nx)
              .attr("height", ny)
              .attr("opacity", 1.0);

            // footer: count outside
            body
              .append("div")
              .attr("class", "foot")
              .text(
                () =>
                  `points: ${pts.length} • outside contour: ${
                    outside.length
                  } (${(
                    (outside.length / Math.max(1, pts.length)) *
                    100
                  ).toFixed(1)}%)  • variant=${vkey} level=${level}`
              );
          }
        }

        selLab.addEventListener("change", render);
        selVar.addEventListener("change", render);
        inpLvl.addEventListener("change", render);

        await render();
      })();
    </script>
  </body>
</html>
