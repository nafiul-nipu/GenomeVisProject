<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>MPASE 2D SVG · Red Contour + Blue Scatter</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        --bg: #0b0b0c;
        --panel: #0e0e11;
        --fg: #eaeaea;
        --grid: #222;
        --scatter: #1f77b4; /* blue points */
        --contour: #d62728; /* red contour */
      }
      html,
      body {
        margin: 0;
        padding: 0;
        background: var(--bg);
        color: var(--fg);
        font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      }
      header {
        padding: 10px 14px;
        border-bottom: 1px solid var(--grid);
        display: flex;
        align-items: center;
        gap: 12px;
      }
      header code {
        background: #111;
        padding: 2px 6px;
        border-radius: 4px;
      }
      #wrap {
        padding: 12px;
      }
      .row {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 12px;
        align-items: start;
      }
      .panel {
        background: var(--panel);
        border: 1px solid var(--grid);
        border-radius: 6px;
        overflow: hidden;
      }
      .panel header {
        border: 0;
        padding: 8px 10px;
        font-weight: 600;
        background: #111214;
      }
      .panel .body {
        padding: 8px;
      }
      svg {
        display: block;
        width: 100%;
        height: auto;
        background: #0f1013;
        border-radius: 4px;
      }

      /* Contour red */
      .contours path {
        fill: none;
        stroke: var(--contour);
        stroke-width: 1.8;
        stroke-opacity: 0.95;
        vector-effect: non-scaling-stroke;
      }

      /* Scatter blue */
      .points circle {
        fill: var(--scatter);
        fill-opacity: 0.8;
        r: 1.6;
      }

      .footnote {
        opacity: 0.75;
        margin-top: 8px;
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  </head>
  <body>
    <header>
      <strong>MPASE 2D SVG</strong>
      <span
        >Red contour + blue scatter · all planes from
        <code>web_data/</code></span
      >
    </header>

    <div id="wrap">
      <div id="metaLine" class="footnote"></div>
      <div class="row" id="row"></div>
    </div>

    <script>
      // ------------ Config ------------
      const ROOT = "web_data";
      const PLANES = ["XY", "YZ", "XZ"];
      const VARIANT = "hdr"; // "hdr" | "point_fraction"
      const LEVEL = 100;
      const LABEL = null; // or set explicitly, e.g. "12h_UNTR"

      // ------------ Utils ------------
      const safeJSON = async (p) => {
        try {
          return await d3.json(p);
        } catch {
          return null;
        }
      };

      const polylineToPath = (pts) =>
        pts && pts.length
          ? "M" + pts.map((p) => `${p[0]},${p[1]}`).join("L") + "Z"
          : "";

      const extent2D = (pts) => {
        let xmin = Infinity,
          xmax = -Infinity,
          ymin = Infinity,
          ymax = -Infinity;
        for (const [x, y] of pts) {
          if (x < xmin) xmin = x;
          if (x > xmax) xmax = x;
          if (y < ymin) ymin = y;
          if (y > ymax) ymax = y;
        }
        return { xmin, xmax, ymin, ymax };
      };

      const bboxIoU = (a, b) => {
        const ix = Math.max(
          0,
          Math.min(a.xmax, b.xmax) - Math.max(a.xmin, b.xmin)
        );
        const iy = Math.max(
          0,
          Math.min(a.ymax, b.ymax) - Math.max(a.ymin, b.ymin)
        );
        const inter = ix * iy;
        const areaA =
          Math.max(0, a.xmax - a.xmin) * Math.max(0, a.ymax - a.ymin);
        const areaB =
          Math.max(0, b.xmax - b.xmin) * Math.max(0, b.ymax - b.ymin);
        const uni = areaA + areaB - inter;
        return uni > 0 ? inter / uni : 0;
      };

      const looksRaster = (pts, nx, ny) => {
        if (!pts || !pts.length) return false;
        const bx = extent2D(pts);
        return (
          bx.xmax <= nx + 1 &&
          bx.ymax <= ny + 1 &&
          bx.xmin >= -1 &&
          bx.ymin >= -1
        );
      };

      // If unit [0..1], scale to raster
      const scaleIfUnit = (pts, nx, ny) => {
        if (!pts || !pts.length) return [];
        const mx = d3.max(pts, (p) => p[0]);
        const my = d3.max(pts, (p) => p[1]);
        if (mx <= 1.01 && my <= 1.01)
          return pts.map(([x, y]) => [x * (nx - 1), y * (ny - 1)]);
        return pts;
      };

      // 8 orientation candidates for contour alignment in raster space
      function orientCandidates(pts, nx, ny) {
        return [
          { name: "id", fn: ([x, y]) => [x, y] },
          { name: "flipX", fn: ([x, y]) => [nx - 1 - x, y] },
          { name: "flipY", fn: ([x, y]) => [x, ny - 1 - y] },
          { name: "flipXY", fn: ([x, y]) => [nx - 1 - x, ny - 1 - y] },
          { name: "swap", fn: ([x, y]) => [y, x] },
          { name: "swapFX", fn: ([x, y]) => [ny - 1 - y, x] },
          { name: "swapFY", fn: ([x, y]) => [y, nx - 1 - x] },
          { name: "swapFXY", fn: ([x, y]) => [ny - 1 - y, nx - 1 - x] },
        ].map((c) => ({ name: c.name, pts: pts.map(c.fn) }));
      }

      const pickPts = (proj, plane, label) => {
        if (!proj || !label) return [];
        const direct = proj[label];
        const nested = proj[plane] && proj[plane][label];
        return nested || direct || [];
      };

      // ------------ Main ------------
      (async function init() {
        // Ensure containers exist
        if (!document.getElementById("metaLine")) {
          const wrap = document.getElementById("wrap") || document.body;
          const metaDiv = document.createElement("div");
          metaDiv.id = "metaLine";
          metaDiv.className = "footnote";
          wrap.prepend(metaDiv);
        }
        if (!document.getElementById("row")) {
          const wrap = document.getElementById("wrap") || document.body;
          const rowDiv = document.createElement("div");
          rowDiv.id = "row";
          rowDiv.className = "row";
          wrap.appendChild(rowDiv);
        }

        const meta = await safeJSON(`${ROOT}/meta_data.json`);
        if (!meta) {
          d3.select("#metaLine").html("<b>meta_data.json</b> not found.");
          return;
        }

        const grid = meta.grid || {};
        const labels = meta.labels || [];
        const chosen = LABEL || labels[0] || "";
        d3.select("#metaLine").html(
          `Variant: <b>${VARIANT}</b> · Level: <b>${LEVEL}%</b> · Label: <b>${chosen}</b> · Planes: <b>${PLANES.join(
            " · "
          )}</b>`
        );

        const row = d3.select("#row");

        for (const plane of PLANES) {
          if (!grid[plane]) continue;
          const [nx, ny] = grid[plane];

          const panel = row.append("div").attr("class", "panel");
          panel.append("header").text(plane);
          const body = panel.append("div").attr("class", "body");

          const svg = body
            .append("svg")
            .attr("viewBox", `0 0 ${nx} ${ny}`)
            .attr("preserveAspectRatio", "xMidYMid meet");

          const gPts = svg.append("g").attr("class", "points");
          const gCtr = svg.append("g").attr("class", "contours");

          // Load
          const proj = await safeJSON(
            `${ROOT}/projections/${plane}_projections.json`
          );
          const cname = chosen.replace(/[^A-Za-z0-9._-]+/g, "_");
          const contourObj = await safeJSON(
            `${ROOT}/contours/${cname}_contour.json`
          );

          // Points → raster-ish
          let ptsRaw = proj ? pickPts(proj, plane, chosen) : [];
          if (!looksRaster(ptsRaw, nx, ny)) {
            // If world coords slipped in, normalize by their own bbox to raster
            const b = extent2D(ptsRaw);
            const toRaster = ([x, y]) => [
              ((x - b.xmin) * (nx - 1)) / Math.max(1e-9, b.xmax - b.xmin),
              ((y - b.ymin) * (ny - 1)) / Math.max(1e-9, b.ymax - b.ymin),
            ];
            ptsRaw = ptsRaw.map(toRaster);
          }
          const pts = scaleIfUnit(ptsRaw, nx, ny);

          // Draw points (blue)
          gPts
            .selectAll("circle")
            .data(pts)
            .join("circle")
            .attr("cx", (d) => d[0])
            .attr("cy", (d) => d[1])
            .attr("r", 1.6);

          // Contours
          const items = (contourObj?.contours || []).filter(
            (d) =>
              d.plane === plane &&
              d.variant === (VARIANT === "point_fraction" ? "pf" : "hdr") &&
              +d.level === +LEVEL
          );
          if (items.length) {
            // Take outermost by area after orientation search
            const ptsBox = extent2D(pts);
            const orientedCandidates = items.map((d) => {
              // First bring contour roughly to raster scale if looks unit
              let base = scaleIfUnit(d.points || [], nx, ny);
              if (!looksRaster(base, nx, ny)) {
                // Normalize by its own bbox to raster for fair orientation test
                const b = extent2D(base);
                const toRaster = ([x, y]) => [
                  ((x - b.xmin) * (nx - 1)) / Math.max(1e-9, b.xmax - b.xmin),
                  ((y - b.ymin) * (ny - 1)) / Math.max(1e-9, b.ymax - b.ymin),
                ];
                base = base.map(toRaster);
              }

              // Try 8 transforms, pick best IoU to points bbox
              const candidates = orientCandidates(base, nx, ny);
              let best = candidates[0],
                bestIoU = -1;
              for (const c of candidates) {
                const cb = extent2D(c.pts);
                const iou = bboxIoU(cb, ptsBox);
                if (iou > bestIoU) {
                  bestIoU = iou;
                  best = c;
                }
              }
              return { ...d, _pts: best.pts, _iou: bestIoU, _name: best.name };
            });

            // Now pick outermost by area among oriented
            const enriched = orientedCandidates.map((d) => ({
              ...d,
              _area: (() => {
                const p = d._pts;
                let a = 0;
                for (let i = 0; i < p.length; i++) {
                  const [x1, y1] = p[i];
                  const [x2, y2] = p[(i + 1) % p.length];
                  a += x1 * y2 - x2 * y1;
                }
                return Math.abs(a) / 2;
              })(),
            }));

            const outer = enriched.reduce(
              (a, b) => (b._area > a._area ? b : a),
              enriched[0]
            );

            // Draw contour (red)
            gCtr
              .selectAll("path")
              .data([outer])
              .join("path")
              .attr("d", (d) => polylineToPath(d._pts));
          }

          gCtr.raise();
        }
      })();
    </script>
  </body>
</html>
