<!DOCTYPE html>
<meta charset="utf-8" />
<title>D3 — contours & separate scatter</title>
<style>
  :root {
    --scale: 1.6;
  }
  body {
    font-family: system-ui, sans-serif;
    margin: 16px;
  }
  .controls label {
    margin-right: 10px;
  }
  .row {
    display: flex;
    gap: 28px;
    align-items: flex-start;
    flex-wrap: wrap;
  }
  .stack {
    position: relative;
    display: inline-block;
  }
  .layer {
    position: absolute;
    left: 0;
    top: 0;
  }
  canvas.layer,
  svg.layer {
    border: 1px solid #ccc;
    background: #fff;
    image-rendering: pixelated;
  }
  .legend {
    font-size: 13px;
    color: #444;
    margin-top: 6px;
  }
  h3 {
    margin: 8px 0;
    font-size: 15px;
    color: #333;
  }
  .a {
    stroke: #1f77b4;
    fill: none;
    stroke-width: 2;
  }
  .b {
    stroke: #d62728;
    fill: none;
    stroke-width: 2;
  }
  .scatterA {
    fill: #1f77b4;
    opacity: 0.75;
  }
  .scatterB {
    fill: #d62728;
    opacity: 0.75;
  }
  .axis path,
  .axis line {
    stroke: #bbb;
  }
</style>

<div class="controls">
  <label
    >Plane
    <select id="plane"></select
  ></label>
  <label
    >Variant
    <select id="variant">
      <option value="hdr">hdr</option>
      <option value="pf">pf</option>
    </select>
  </label>
  <label
    >Level
    <select id="level"></select
  ></label>
  <label><input type="checkbox" id="showMask" checked /> show mask</label>
</div>

<div class="row">
  <!-- Left: pixel-accurate mask+contour -->
  <div>
    <h3>Mask + Contours</h3>
    <div id="stack" class="stack">
      <canvas id="mask" class="layer"></canvas>
      <svg id="svgContours" class="layer"></svg>
    </div>
    <div id="legendContours" class="legend"></div>
  </div>

  <!-- Right: auto-scaled scatter (independent axes) -->
  <div>
    <h3>Scatter (auto-scaled to projections)</h3>
    <svg id="svgScatter" width="520" height="520"></svg>
    <div id="legendScatter" class="legend"></div>
  </div>
</div>

<script type="module">
  (async () => {
    // error hooks
    window.addEventListener("error", (e) =>
      console.error("[onerror]", e.error || e.message)
    );
    window.addEventListener("unhandledrejection", (e) =>
      console.error("[unhandledrejection]", e.reason)
    );

    let d3;
    try {
      d3 = await import("https://cdn.jsdelivr.net/npm/d3@7/+esm");
      console.log("[boot] d3 loaded", d3.version || "ok");
    } catch (err) {
      console.error("[boot] failed to load d3", err);
      return;
    }

    // data
    const ROOT = "./web_data";
    const meta = await (await fetch(`${ROOT}/meta.json`)).json();
    const bgmask = await (await fetch(`${ROOT}/background_mask.json`)).json();
    const contoursAll = await (await fetch(`${ROOT}/contours_d3.json`)).json();
    const projections = await (await fetch(`${ROOT}/projections.json`)).json();
    const metrics = await (await fetch(`${ROOT}/metrics.json`)).json();

    // dom
    const planeSel = d3.select("#plane");
    const variantSel = d3.select("#variant");
    const levelSel = d3.select("#level");
    const showMask = d3.select("#showMask");

    meta.planes.forEach((p) =>
      planeSel.append("option").attr("value", p).text(p)
    );
    planeSel.property("value", meta.planes[0]);

    function setLevels() {
      const v = variantSel.property("value");
      const lvls = v === "hdr" ? meta.levels.hdr : meta.levels.pf;
      levelSel.selectAll("option").remove();
      (lvls?.length ? lvls : [100]).forEach((L) =>
        levelSel.append("option").attr("value", L).text(L)
      );
      levelSel.property("value", lvls?.length ? lvls[0] : 100);
    }
    setLevels();
    planeSel.on("change", renderAll);
    variantSel.on("change", () => {
      setLevels();
      renderAll();
    });
    levelSel.on("change", renderAll);
    showMask.on("change", renderAll);

    // left panel sizing
    const maskCanvas = document.getElementById("mask");
    const svgContours = d3.select("#svgContours");
    const legendContours = d3.select("#legendContours");
    const stack = document.getElementById("stack");

    function sizeLeft(nx, ny) {
      const scale = 1.6;
      const W = nx * scale,
        H = ny * scale;
      // intrinsic pixels
      maskCanvas.width = nx;
      maskCanvas.height = ny;
      // css size
      maskCanvas.style.width = W + "px";
      maskCanvas.style.height = H + "px";
      svgContours
        .attr("viewBox", `0 0 ${nx} ${ny}`)
        .attr("width", W)
        .attr("height", H);
      // layer positions
      [maskCanvas, svgContours.node()].forEach((el) => {
        el.style.left = "0px";
        el.style.top = "0px";
      });
      stack.style.width = W + "px";
      stack.style.height = H + "px";
    }

    function drawMask(plane) {
      const arr = bgmask?.[plane];
      if (!arr) {
        maskCanvas.style.display = "none";
        return;
      }
      const ny = arr.length,
        nx = arr[0].length;
      const ctx = maskCanvas.getContext("2d", { willReadFrequently: true });
      // white base
      ctx.fillStyle = "#fff";
      ctx.fillRect(0, 0, nx, ny);
      // gray where mask==1
      const img = ctx.createImageData(nx, ny);
      let p = 0;
      for (let y = 0; y < ny; y++) {
        const row = arr[y];
        for (let x = 0; x < nx; x++) {
          const on = row[x] ? 1 : 0;
          if (on) {
            img.data[p++] = 90;
            img.data[p++] = 90;
            img.data[p++] = 90;
            img.data[p++] = 255;
          } else {
            img.data[p++] = 0;
            img.data[p++] = 0;
            img.data[p++] = 0;
            img.data[p++] = 0;
          }
        }
      }
      ctx.putImageData(img, 0, 0);
      maskCanvas.style.visibility = showMask.property("checked")
        ? "visible"
        : "hidden";
    }

    function drawContours(plane, variant, level) {
      const line = d3
        .line()
        .x((d) => d[0])
        .y((d) => d[1]);
      const rows = (contoursAll?.contours || []).filter(
        (d) => d.plane === plane && d.variant === variant && d.level === +level
      );
      const g = svgContours
        .selectAll("g.main")
        .data([0])
        .join("g")
        .attr("class", "main");
      g.selectAll("path.c")
        .data(rows, (d) => d.label + d.variant + d.level)
        .join(
          (enter) =>
            enter
              .append("path")
              .attr("class", "c")
              .attr("stroke", (d) => (d.label === "A" ? "#1f77b4" : "#d62728"))
              .attr("fill", "none")
              .attr("stroke-width", 2)
              .attr("d", (d) => line(d.points)),
          (update) => update.attr("d", (d) => line(d.points)),
          (exit) => exit.remove()
        );
    }

    function drawLegendContours(plane, variant, level) {
      const v = variant === "pf" ? "point_fraction" : "hdr";
      const m = metrics.find(
        (d) => d.plane === plane && d.variant === v && d.level === +level
      );
      legendContours.html(
        m
          ? `<b>${plane}</b> — ${variant} ${level}%<br>IoU: ${(
              +m.IoU ||
              +m.IuO ||
              0
            ).toFixed(3)} | meanNN: ${(+(m.meanNN || 0)).toFixed(
              3
            )} | Hausdorff: ${(+(m.Hausdorff || 0)).toFixed(3)}`
          : `<b>${plane}</b> — ${variant} ${level}%`
      );
    }

    // right panel (independent axes)
    const svgScatter = d3.select("#svgScatter");
    const legendScatter = d3.select("#legendScatter");
    const M = { t: 22, r: 28, b: 36, l: 40 };
    function drawScatter(plane) {
      const W = +svgScatter.attr("width"),
        H = +svgScatter.attr("height");
      const innerW = W - M.l - M.r,
        innerH = H - M.t - M.b;
      svgScatter.selectAll("*").remove();
      const g = svgScatter
        .append("g")
        .attr("transform", `translate(${M.l},${M.t})`);

      const proj = projections?.[plane] || { A: [], B: [] };
      const all = [...proj.A, ...proj.B];
      if (!all.length) {
        legendScatter.text("No projection points");
        return;
      }

      // compute domains from data directly (works for pixels or normalized or anything)
      const xMin = d3.min(all, (d) => d[0]),
        xMax = d3.max(all, (d) => d[0]);
      const yMin = d3.min(all, (d) => d[1]),
        yMax = d3.max(all, (d) => d[1]);
      // add a small 5% padding
      const padX = (xMax - xMin) * 0.05 || 1;
      const padY = (yMax - yMin) * 0.05 || 1;

      const x = d3
        .scaleLinear()
        .domain([xMin - padX, xMax + padX])
        .range([0, innerW]);
      const y = d3
        .scaleLinear()
        .domain([yMin - padY, yMax + padY])
        .range([innerH, 0]); // Cartesian up

      const ax = d3.axisBottom(x).ticks(6);
      const ay = d3.axisLeft(y).ticks(6);
      g.append("g")
        .attr("transform", `translate(0,${innerH})`)
        .attr("class", "axis")
        .call(ax);
      g.append("g").attr("class", "axis").call(ay);

      const r = Math.max(1.8, Math.min(3.5, Math.sqrt(all.length) / 2));
      g.selectAll("circle.a")
        .data(proj.A)
        .join("circle")
        .attr("class", "a")
        .attr("cx", (d) => x(d[0]))
        .attr("cy", (d) => y(d[1]))
        .attr("r", r)
        .attr("fill", "#1f77b4")
        .attr("fill-opacity", 0.7);
      g.selectAll("circle.b")
        .data(proj.B)
        .join("circle")
        .attr("class", "b")
        .attr("cx", (d) => x(d[0]))
        .attr("cy", (d) => y(d[1]))
        .attr("r", r)
        .attr("fill", "#d62728")
        .attr("fill-opacity", 0.7);

      legendScatter.text(`Scatter — ${plane} (auto-scaled to projection data)`);
    }

    function renderAll() {
      const plane = planeSel.property("value");
      const variant = variantSel.property("value");
      const level = +levelSel.property("value");
      const [nx, ny] = meta.grid[plane];

      sizeLeft(nx, ny);
      drawMask(plane);
      drawContours(plane, variant, level);
      drawLegendContours(plane, variant, level);
      drawScatter(plane);
    }

    renderAll();
  })();
</script>
