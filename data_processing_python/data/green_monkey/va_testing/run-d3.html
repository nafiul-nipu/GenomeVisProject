<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>D3 Silhouette Viewer — SVG image mask under contours</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
      body {
        font-family: system-ui, sans-serif;
        margin: 20px;
      }
      .row {
        display: flex;
        gap: 24px;
        align-items: flex-start;
        flex-wrap: wrap;
      }
      .panel {
        display: inline-block;
      }
      svg {
        border: 1px solid #ccc;
        background: #fff;
      }
      .legend {
        font-size: 13px;
        color: #444;
        margin-top: 6px;
      }
      .controls label {
        margin-right: 8px;
      }

      /* contour styles */
      .a {
        stroke: #1f77b4;
        fill: none;
        stroke-width: 2;
      }
      .b {
        stroke: #d62728;
        fill: none;
        stroke-width: 2;
      }

      /* scatter axes */
      .axis path,
      .axis line {
        stroke: #bbb;
      }
    </style>
  </head>
  <body>
    <div class="controls">
      <label
        >Plane
        <select id="plane"></select>
      </label>
      <label
        >Variant
        <select id="variant">
          <option value="hdr">hdr</option>
          <option value="pf">pf</option>
        </select>
      </label>
      <label
        >Level
        <select id="level"></select>
      </label>
      <label>
        Background
        <select id="bgMode">
          <option value="mask" selected>mask</option>
          <option value="densityA">density A</option>
          <option value="densityB">density B</option>
          <option value="densityAB">combined density</option>
          <option value="none">none</option>
        </select>
      </label>
    </div>

    <div class="row">
      <!-- Single SVG: raster mask as <image> UNDER contour paths -->
      <div class="panel">
        <svg id="viz"></svg>
        <div class="legend" id="legendContours"></div>
      </div>

      <!-- Separate, auto-scaled scatter -->
      <div class="panel">
        <div id="scatterMount"></div>
        <div class="legend" id="legendScatter"></div>
      </div>
    </div>

    <script type="module">
      (async () => {
        window.addEventListener("error", (e) =>
          console.error("[window.onerror]", e.error || e.message)
        );
        window.addEventListener("unhandledrejection", (e) =>
          console.error("[unhandledrejection]", e.reason)
        );
        console.log("[boot] module started");

        // Load d3
        let d3;
        try {
          d3 = await import("https://cdn.jsdelivr.net/npm/d3@7/+esm");
          console.log("[boot] d3 loaded", d3.version || "ok");
        } catch (err) {
          console.error("[boot] failed to load d3", err);
          return;
        }

        // --- helpers ---
        async function loadJson(url, { optional = false } = {}) {
          const res = await fetch(url);
          if (!res.ok) {
            const msg = `[fetch] ${res.status} ${res.statusText} for ${url}`;
            if (optional) {
              console.warn(msg);
              return null;
            }
            throw new Error(msg);
          }
          return res.json();
        }

        // Resolve ROOT robustly
        const ROOT = new URL("./web_data/", window.location.href)
          .toString()
          .replace(/\/$/, "");

        // 1) meta / metrics (renamed)
        const meta = await loadJson(`${ROOT}/meta_data.json`);
        const metricsRaw = await loadJson(`${ROOT}/metrics_data.json`);

        // Some old code expects meta.levels.hdr / meta.levels.pf; if your meta has a flat "levels",
        // mirror it so the UI still works.
        if (!meta.levels?.hdr && meta.levels) {
          meta.levels = { hdr: meta.levels, pf: meta.levels };
        }

        // 2) background mask (same name)
        const bgmask = await loadJson(`${ROOT}/background_mask.json`);

        // 3) projections (now split per plane file)
        const projXY = await loadJson(
          `${ROOT}/projections/XY_projections.json`
        );
        const projXZ = await loadJson(
          `${ROOT}/projections/XZ_projections.json`
        );
        const projYZ = await loadJson(
          `${ROOT}/projections/YZ_projections.json`
        );

        // Normalized shape the rest of the code expects: projections[plane] = { A: [[x,y]...], B: [[x,y]...] }
        const projections = {
          XY: projXY ?? { A: [], B: [] },
          XZ: projXZ ?? { A: [], B: [] },
          YZ: projYZ ?? { A: [], B: [] },
        };

        // 4) contours (two files, UNTR → A, VACV → B). We’ll merge into the legacy "contoursAll.contours" array.
        const ctrA = await loadJson(`${ROOT}/contours/12h_UNTR_contour.json`);
        const ctrB = await loadJson(`${ROOT}/contours/12h_VACV_contour.json`);

        // Your contour JSON likely looks like { XY: [[x,y]...], XZ: [...], YZ: [...] } or similar.
        // Build rows like: { plane:'XY', variant:'hdr', level:<first meta level>, label:'A'|'B', points:[[x,y]...] }
        function toRows(obj, label) {
          if (!obj) return [];
          const defaultLevel = meta.levels?.hdr?.[0] ?? meta.levels?.[0] ?? 100;
          const planes = Object.keys(obj); // expect XY/XZ/YZ
          const rows = [];
          for (const plane of planes) {
            const value = obj[plane];
            // value may be a **single polygon** or an **array of polygons** per plane; normalize to array of arrays
            const polys = Array.isArray(value?.[0]?.[0]) ? value : [value];
            for (const poly of polys) {
              rows.push({
                plane,
                variant: "hdr", // if you also have PF, you can duplicate rows with variant:'pf'
                level: +defaultLevel,
                label, // 'A' or 'B'
                points: poly, // [[x,y], ...]
              });
            }
          }
          return rows;
        }

        const contoursAll = {
          contours: [...toRows(ctrA, "A"), ...toRows(ctrB, "B")],
        };

        // 5) densities (two files; UNTR→A, VACV→B). Normalize as densityA[plane][y][x]
        const densityA = await loadJson(
          `${ROOT}/density/12h_UNTR_density.json`,
          { optional: true }
        );
        const densityB = await loadJson(
          `${ROOT}/density/12h_VACV_density.json`,
          { optional: true }
        );

        // 6) metrics: normalize from metrics_data.json to array of rows the legend code expects
        // Expect something like per-plane metrics; if your keys differ, tweak mapping below.
        const metrics = Array.isArray(metricsRaw)
          ? metricsRaw.map((m) => ({
              plane: m.plane ?? m.Plane ?? "XY",
              variant: m.variant ?? m.Variant ?? "hdr",
              level: +(m.level ?? m.Level ?? meta.levels?.hdr?.[0] ?? 100),
              IoU: +(m.IoU ?? m.IuO ?? m.iou ?? 0),
              meanNN: +(m.meanNN ?? m.mean_nn ?? 0),
              Hausdorff: +(m.Hausdorff ?? m.hausdorff ?? 0),
            }))
          : [];

        const planes = meta.planes ?? Object.keys(projections);
        console.log("[data] ok", {
          planes,
          contours: contoursAll?.contours?.length || 0,
        });

        // --- DOM refs ---
        const planeSel = d3.select("#plane");
        const variantSel = d3.select("#variant");
        const levelSel = d3.select("#level");
        const bgModeSel = d3.select("#bgMode");

        const svgViz = d3.select("#viz");
        const legendCtrs = d3.select("#legendContours");

        // right scatter (js-created SVG to avoid parser issues)
        const scatterMount = document.getElementById("scatterMount");
        const svgScatter = d3
          .create("svg")
          .attr("id", "scatter")
          .attr("width", 520)
          .attr("height", 520);
        scatterMount.appendChild(svgScatter.node());
        const legendScatter = d3.select("#legendScatter");

        // Populate planes and levels
        planeSel
          .selectAll("option")
          .data(planes)
          .join("option")
          .attr("value", (d) => d)
          .text((d) => d);
        planeSel.property("value", planes[0]);

        function setLevels() {
          const v = variantSel.property("value");
          const levels = v === "hdr" ? meta.levels.hdr : meta.levels.pf;
          levelSel.selectAll("option").remove();
          (levels?.length ? levels : [100]).forEach((L) =>
            levelSel.append("option").attr("value", L).text(L)
          );
          levelSel.property("value", levels?.length ? levels[0] : 100);
        }
        setLevels();

        planeSel.on("change", renderAll);
        variantSel.on("change", () => {
          setLevels();
          renderAll();
        });
        levelSel.on("change", renderAll);
        bgModeSel.on("change", renderAll);

        // ---- turbo colormap ----
        function lerp(a, b, t) {
          return a + (b - a) * t;
        }
        function lerpRGB(c0, c1, t) {
          return [
            Math.round(lerp(c0[0], c1[0], t)),
            Math.round(lerp(c0[1], c1[1], t)),
            Math.round(lerp(c0[2], c1[2], t)),
          ];
        }
        const TURBO = [
          [48, 18, 59],
          [69, 105, 163],
          [48, 173, 119],
          [171, 220, 53],
          [253, 231, 37],
          [244, 130, 30],
          [133, 23, 75],
        ];
        function sampleGradient(stops, t) {
          t = Math.max(0, Math.min(1, t));
          const n = stops.length - 1;
          const f = t * n;
          const i = Math.min(n - 1, Math.floor(f));
          const local = f - i;
          return lerpRGB(stops[i], stops[i + 1], local);
        }
        function mapColor(v01) {
          return sampleGradient(TURBO, v01);
        }

        // --- helpers: make dataURL image from mask (+ optional density) ---
        function makeMaskDataURL(plane, mode = "mask") {
          const arr = bgmask?.[plane];
          if (!arr) return null;

          const ny = arr.length,
            nx = arr[0].length;
          const c = document.createElement("canvas");
          c.width = nx;
          c.height = ny;
          const ctx = c.getContext("2d", { willReadFrequently: true });

          // white base
          ctx.fillStyle = "#ffffff";
          ctx.fillRect(0, 0, nx, ny);

          // ----- density underlay -----
          let dens = null;
          if (mode === "densityA") dens = densityA?.[plane] || null;
          else if (mode === "densityB") dens = densityB?.[plane] || null;
          else if (mode === "densityAB") {
            const a = densityA?.[plane],
              b = densityB?.[plane];
            if (a && b) {
              const norm = (M) => {
                let mn = Infinity,
                  mx = -Infinity;
                for (let y = 0; y < ny; y++)
                  for (let x = 0; x < nx; x++) {
                    const v = M[y][x];
                    if (v < mn) mn = v;
                    if (v > mx) mx = v;
                  }
                const rng = mx - mn || 1;
                return Array.from({ length: ny }, (_, y) =>
                  Array.from({ length: nx }, (_, x) => (M[y][x] - mn) / rng)
                );
              };
              const na = norm(a),
                nb = norm(b);
              dens = Array.from({ length: ny }, (_, y) =>
                Array.from({ length: nx }, (_, x) =>
                  Math.max(na[y][x], nb[y][x])
                )
              );
            } else dens = a || b || null;
          }

          if (dens) {
            // normalize if needed
            let mn = Infinity,
              mx = -Infinity;
            for (let y = 0; y < ny; y++)
              for (let x = 0; x < nx; x++) {
                const v = dens[y][x];
                if (v < mn) mn = v;
                if (v > mx) mx = v;
              }
            const rng = mx - mn || 1;

            const A = Math.round(0.38 * 255);
            const imgD = ctx.createImageData(nx, ny);
            let q = 0;
            for (let y = 0; y < ny; y++) {
              for (let x = 0; x < nx; x++) {
                const v01 = (dens[y][x] - mn) / rng;
                const [r, g, b] = mapColor(v01); // turbo colormap
                imgD.data[q++] = r;
                imgD.data[q++] = g;
                imgD.data[q++] = b;
                imgD.data[q++] = A;
              }
            }
            ctx.putImageData(imgD, 0, 0);
          }

          // ----- mask overlay -----
          if (mode === "mask") {
            const alphaMask = Math.round(0.45 * 255);
            const gray = 140;
            const img = ctx.createImageData(nx, ny);
            let p = 0;
            for (let y = 0; y < ny; y++) {
              const row = arr[y];
              for (let x = 0; x < nx; x++) {
                if (row[x]) {
                  img.data[p++] = gray;
                  img.data[p++] = gray;
                  img.data[p++] = gray;
                  img.data[p++] = alphaMask;
                } else {
                  img.data[p++] = 0;
                  img.data[p++] = 0;
                  img.data[p++] = 0;
                  img.data[p++] = 0;
                }
              }
            }
            ctx.putImageData(img, 0, 0);
          }

          return c.toDataURL("image/png");
        }

        // --- draw mask image + contours in ONE SVG ---
        function drawMaskAndContours(plane, variant, level) {
          const [nx, ny] = meta.grid[plane];
          const scale = 3.2,
            W = nx * scale,
            H = ny * scale;

          // size SVG
          svgViz
            .attr("viewBox", `0 0 ${nx} ${ny}`)
            .attr("width", W)
            .attr("height", H);

          // ensure a single root group
          const root = svgViz
            .selectAll("g.root")
            .data([0])
            .join("g")
            .attr("class", "root");

          // (1) Mask image layer (raster) — UNDER
          const mode = bgModeSel.property("value"); // "mask" | "density" | "both" | "none"
          const url = mode === "none" ? null : makeMaskDataURL(plane, mode);
          const imgSel = root.selectAll("image.mask").data(url ? [url] : []);

          imgSel.join(
            (enter) =>
              enter
                .append("image")
                .attr("class", "mask")
                .attr("x", 0)
                .attr("y", 0)
                .attr("width", nx)
                .attr("height", ny)
                .attr("preserveAspectRatio", "none")
                .attr("href", url),
            (update) => update.attr("href", url),
            (exit) => exit.remove()
          );

          // (2) Contours — OVER
          const line = d3
            .line()
            .x((d) => d[0])
            .y((d) => d[1]);
          const rows = (contoursAll?.contours || []).filter(
            (d) =>
              d.plane === plane && d.variant === variant && d.level === +level
          );
          const g = root
            .selectAll("g.contours")
            .data([0])
            .join("g")
            .attr("class", "contours");
          g.selectAll("path.c")
            .data(rows, (d) => d.label + d.variant + d.level)
            .join(
              (enter) =>
                enter
                  .append("path")
                  .attr("class", "c")
                  .attr("stroke", (d) =>
                    d.label === "A" ? "#1f77b4" : "#d62728"
                  )
                  .attr("fill", "none")
                  .attr("stroke-width", 2)
                  .attr("d", (d) => line(d.points)),
              (update) => update.attr("d", (d) => line(d.points)),
              (exit) => exit.remove()
            );

          // (3) Legend
          const vKey = variant === "pf" ? "point_fraction" : "hdr";
          const m = metrics?.find(
            (d) => d.plane === plane && d.variant === vKey && d.level === +level
          );
          legendCtrs.html(
            m
              ? `<b>${plane}</b> — ${variant} ${level}% | bg: ${mode}<br>IoU: ${(
                  +m.IoU ||
                  +m.IuO ||
                  0
                ).toFixed(3)} | meanNN: ${(+(m.meanNN || 0)).toFixed(
                  3
                )} | Hausdorff: ${(+(m.Hausdorff || 0)).toFixed(3)}`
              : `<b>${plane}</b> — ${variant} ${level}% | bg: ${mode}`
          );
        }

        // --- separate scatter ---
        const M = { t: 24, r: 28, b: 36, l: 44 };
        function drawScatter(plane) {
          const W = +svgScatter.attr("width"),
            H = +svgScatter.attr("height");
          const innerW = W - M.l - M.r,
            innerH = H - M.t - M.b;

          const s = d3.select(svgScatter.node());
          s.selectAll("*").remove();
          const g = s.append("g").attr("transform", `translate(${M.l},${M.t})`);

          const proj = projections?.[plane] || { A: [], B: [] };
          const all = [...(proj.A || []), ...(proj.B || [])];

          if (!all.length) {
            legendScatter.text("No projection points");
            return;
          }

          const xMin = d3.min(all, (d) => d[0]),
            xMax = d3.max(all, (d) => d[0]);
          const yMin = d3.min(all, (d) => d[1]),
            yMax = d3.max(all, (d) => d[1]);
          const padX = (xMax - xMin) * 0.05 || 1,
            padY = (yMax - yMin) * 0.05 || 1;

          const x = d3
            .scaleLinear()
            .domain([xMin - padX, xMax + padX])
            .range([0, innerW]);
          const y = d3
            .scaleLinear()
            .domain([yMin - padY, yMax + padY])
            .range([innerH, 0]);

          g.append("g")
            .attr("transform", `translate(0,${innerH})`)
            .attr("class", "axis")
            .call(d3.axisBottom(x).ticks(6));
          g.append("g").attr("class", "axis").call(d3.axisLeft(y).ticks(6));

          const r = 2;
          g.selectAll("circle.a")
            .data(proj.A || [])
            .join("circle")
            .attr("cx", (d) => x(d[0]))
            .attr("cy", (d) => y(d[1]))
            .attr("r", r)
            .attr("fill", "#1f77b4")
            .attr("fill-opacity", 0.7);
          g.selectAll("circle.b")
            .data(proj.B || [])
            .join("circle")
            .attr("cx", (d) => x(d[0]))
            .attr("cy", (d) => y(d[1]))
            .attr("r", r)
            .attr("fill", "#d62728")
            .attr("fill-opacity", 0.7);

          legendScatter.text(
            `Scatter — ${plane} (auto-scaled to projection data)`
          );
        }

        // --- render orchestration ---
        function renderAll() {
          const plane = planeSel.property("value");
          const variant = variantSel.property("value");
          const level = +levelSel.property("value");

          drawMaskAndContours(plane, variant, level); // single SVG with raster <image> + paths
          drawScatter(plane);
        }

        renderAll();
        console.log("[render] done");
      })();
    </script>
  </body>
</html>
